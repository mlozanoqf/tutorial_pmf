```{r echo=FALSE}
rm(list=ls())
library(PortfolioAnalytics)
library(ROI)
library(ROI.plugin.glpk)
library(ROI.plugin.quadprog)
library(dplyr)
library(tbl2xts)
library(tidyquant)
library(ggplot2)
library(MASS)
```

\newpage


# Asset allocation.

In finance, we are expected to take good financing and investment decisions. Asset allocation and portfolio theory are areas that show how we can take optimal investment decisions. In general, optimization is the act of achieving the best possible result under given circumstances. In our context, the best possible result is the highest return given a risk level, or alternatively the lowest risk given a return level. The *given circumstances* refer to a set of restrictions or constraints that we can face in the market. These restrictions are in the form of a maximum level of one asset in a portfolio, constraints about short sales, etc. Computers can solve complex optimization problems so it makes sense to use R and conduct asset allocation and tasks and estimate portfolio optimization models.

In principle, we all know that the popular wisdom suggests *not to put all the eggs in the same basket*. This suggestion makes sense as we should diversify as diversification is a way to manage the risk of losing all the eggs if something bad happens. For example, imagine I invest in two firms, one that sells ice cream and another that sells hot chocolate. Assume that as an exchange of my investment, I get some returns based on these firms' sales. My diversification in these two firms seems reasonable as the weather (relevant risk factor) affects the sales of these two companies in an opposite way. In particular, when it is hot, sales increases in the ice cream shop and decreases in the hot chocolate shop; and when it is cold, sales increases in the hot chocolate shop and decreases in the ice cream shop. Then, my revenues will be fairly constant every year, and this is desirable as I reduce the volatility of my revenues, they become less risky, the standard deviation of my revenues is small. You may remember our previous discussion about the correlation of Mastercard and Visa, the correlation of these firms' stock returns is 0.8480487 and we argue that this mean that they not only share the same risk factors, but they also react almost the same to changes in these risk factors, and this is why they behave similar. In the ice cream and hot chocolate shop example, we could guess that the sales' correlation of both shops have a strong negative correlation let's say −0.9. This means that the sales of both shops behave opposite and they are affected differently by the risk factor called weather.

If the popular wisdom suggests *not to put all the eggs in the same basket*, then, the interesting question is, how many eggs should we put in each basket? This is the equivalent to an investment recommendation in the form of how much to invest in each individual asset. We call portfolio to the new asset formed by several and smaller investments in single assets. And we call a portfolio weight to the percentage invested in single assets. Asset allocation models allow us to estimate these optimal portfolio weights. Let's see an extreme example first. Imagine my current investment is 1% in the ice cream shop and 99% in the hot chocolate shop. This does not look like a good idea because these portfolio weights make the portfolio highly vulnerable to hot weather. After implementing an asset allocation optimization, the portfolio weights could be 60% of my money invested in the ice cream shop and 40% in the hot chocolate shop.

## The single-period problem.

The single-period problem is the simplest framework to implement asset allocation models. Here, we assume that the investor has some historical information about the assets in $t=0$ (today), she makes an investment decision today, and she expects a return in $t=1$, end of story. 

Let's see how we should distribute the 100% of available money to invest in four stocks using the <tt>`PortfolioAnalytics`</tt> R package. We need data to start. For convenience, we use the monthly returns of the <tt>`FANG`</tt> database.

```{r}
FANG_monthly_returns <- FANG |>
    group_by(symbol) |>
    tq_transmute(select     = adjusted,
                 mutate_fun = periodReturn,
                 period     = "monthly",
                 type       = "arithmetic")

FANG_monthly_returns
```

The format of <tt>`FANG_monthly_returns`</tt> is not compatible with the <tt>`PortfolioAnalytics`</tt> package as the data is currently tidy. So, we have to transform the way our database looks. Originally, we have a column called <tt>`symbol`</tt> and we need each stock to have their corresponding name in different columns. We can implement this change easily.

```{r}
fang <- FANG_monthly_returns |> 
  tbl_xts(spread_by = "symbol")

head(fang)
```

As you can confirm, the <tt>`FANG`</tt> database is the same as we only changed the format. Following our discussion about the correlation, we calculate the correlation matrix for these 4 stocks.

```{r}
cor(fang)
```

The lowest correlation is between FB and AMZN (0.1846197). This means that both firms exhibit a weak linear relationship. On the other hand, we have GOOG and AMZN with a correlation of 0.6171376, which suggest a stronger linear relationship between these stock returns. In principle, the lower the correlation of our assets, the greater the diversification possibilities when forming a portfolio. Remember the ice cream and the hot chocolate shop example, we assumed a correlation of −0.9 and we were supposed to decrease the volatility of our sales. In practice, it is not very easy to find negative correlated assets. However, we can achieve diversification gains as long as the correlation value is less than +1.

Let's continue with our main objective. We are interested in an investment recommendation (how much to invest in each of the four assets). 

We first define a portfolio specification with the help of <tt>`portfolio.spec()`</tt> function. 

```{r}
# Create the portfolio specification
port_spec <- portfolio.spec(colnames(fang))
port_spec
```

Given the portfolio specification, we are interested in four assets. Now, add a full investment constraint such that the weights sum to 1. In practical terms, a sum exactly equal to 1 is too restrictive for the optimization, so we allow weights to sum between 0.99 and 1.01. We use the <tt>`add.constraint()`</tt> function. 

```{r}
port_spec <- add.constraint(portfolio = port_spec, type = "weight_sum",
                            min_sum = 0.99, max_sum = 1.01)
port_spec
```

Add a box constraint such that the portfolio optimal weights are between 0 and 1. This is equivalent as a *long only* constraint.

```{r}
port_spec <- add.constraint(portfolio = port_spec, type = "box", 
                            min = 0, max = 1)
port_spec
```

We are interested in risk and return.

```{r}
# Add an objective to minimize portfolio standard deviation
port_spec <- add.objective(portfolio = port_spec,
                           type = "risk",
                           name = "StdDev")
port_spec <- add.objective(portfolio = port_spec,
                           type = "return",
                           name = "mean")
port_spec
```

The portfolio specification indicates that we have four assets available, these are: FB, AMZN, NFLX and GOOG. Constraints indicates that we are expected to spend 100% of the funds available, or very close to that. The constraint long refers that individual portfolio weights have to be positive.

The alternative of the box constraint is to allow the model to deliver negative portfolio weights. Negative portfolio weights represent short sales. Short selling is an investment strategy that speculates on the decline in a stock. Sometimes short selling is not allowed so the box constraint will deliver only positive portfolio weights. 

The <tt>`optimize.portfolio()`</tt> function allows us to solve our portfolio problem by taking a variety of methods, constraints and objectives. Let's run two of them: random and ROI, and then we can discuss their differences.

```{r}
# Solve the optimization problem.
set.seed(13)
opt_rand <- optimize.portfolio(fang, portfolio = port_spec, 
                               optimize_method = "random", trace = TRUE)
opt_roi <- optimize.portfolio(fang, portfolio = port_spec, 
                              optimize_method = "ROI", trace = TRUE)
# Show optimization results.
opt_rand
opt_roi
```



The output above shows the portfolio weights, return and risk of the two optimal portfolios. Before showing the results of this optimization in a plot, let's look at the initial situation. In particular, the individual assets before considering any portfolio.

First, the relevant <tt>`FANG`</tt> data.

```{r}
FANG_monthly_returns <- FANG |>
    group_by(symbol) |>
    tq_transmute(select     = adjusted,
                 mutate_fun = periodReturn,
                 period     = "monthly",
                 type       = "arithmetic")

FANG_stats <- FANG_monthly_returns |>
summarise(mean = mean(monthly.returns), 
          sd = sd(monthly.returns), 
          sr = mean/sd)

FANG_stats
```


```{r}
#| label: fig-ftfia
#| fig-cap: "FANG, the four individual assets."
ggplot(FANG_stats, aes(x = sd, y = mean, color = symbol)) +
  geom_point(size = 5) + 
  geom_text(aes(label = paste0(symbol)), 
  vjust = 2, color = "black", size = 3.5) +
  labs(x = "Risk", y = "Return") + 
  scale_y_continuous(limits = c(0.01, 0.06), 
                     labels = scales::percent) +
  scale_x_continuous(labels = scales::percent) +
  theme_tq() +
  theme(legend.position = "none", legend.title = element_blank())
```

Do you remember this plot above from previous sections? This is basically the four individual assets in the mean-variance space. The proposal of asset allocation is that instead of choosing one individual asset to invest in, we can do better by creating a portfolio. As we argue before, the role of the optimization process is precisely to determine which allocation is the most efficient.

For example, I do not think you will be happy with a portfolio whose return is 0.035 (3.5% monthly return) and a risk of 0.15 (15% standard deviation). This is because you could do better than that. For example, Facebook has a similar return with a 10% risk. But what if I propose a portfolio with a return of 4% and a risk of 5%? That would be great compared with the individual assets alternatives as it is a 0.8 return per unit of risk.

The random technique (Random Portfolios Optimization) evaluates many investment recommendation alternatives, each one is one portfolio. In principle, the technique should recommend a portfolio which leads to a more attractive return per unit of risk alternative than investing in individual assets.

```{r}
#| label: fig-frmop
#| fig-cap: "FANG, random method optimal portfolio."
# Plot results.
chart.RiskReward(opt_rand, risk.col = "StdDev", 
                 return.col = "mean", chart.assets = TRUE, 
                 xlim = c(0, 0.10))
abline(v = 0.05941703, lty = 2)
abline(h = 0.02566966, lty = 2)
legend("bottomright", legend = c("opt_rand", "equally_weighted"),
       col = c("blue", "orange"), pch = 19, cex = 0.9)
```

According to our portfolio specification and assets, gray circles represent feasible portfolios in the sense that they are possible combinations given the individual assets. Note that there are some available portfolios with a lower risk than GOOG. In fact, the algorithm suggests the blue portfolio as the optimal portfolio. This blue portfolio is attractive because it has the same risk than GOOG, but it has higher expected return. Moreover, our optimal blue portfolio has a similar return as AMZN, but with less risk. So, apparently the blue alternative is an attractive investment recommendation. Note that the gray portfolios form a kind of frontier in this mean-variance plot. This frontier suggests that it is not possible to invest in a portfolio at the left of this frontier. The optimal portfolio lies just in the frontier.

See the blue optimal portfolio again. We would prefer any other portfolio located in the top (higher return) or at the left (lower risk), but that is impossible given the data. On the other hand, it is possible to achieve a portfolio located below (low return) or at the right (high risk), but that is not optimal. This is why optimal portfolios are those that lie in the frontier, those are the portfolios located in the extreme high and left of this mean-variance plot.

Then, what can we do to invest in the blue optimal portfolio?


```{r}
#| label: fig-frmow
#| fig-cap: "FANG, random method optimal weights."
chart.Weights(opt_rand)
```

According to the <tt>`opt_rand`</tt> portfolio, we have to invest:

```{r}
extractWeights(opt_rand)
```

```{r}
opt_rand_mean <- as.numeric(extractObjectiveMeasures(opt_rand)$mean)
opt_rand_sd <- 
  as.numeric(extractObjectiveMeasures(opt_rand)$StdDev[1,1])
opt_rand_sr <- opt_rand_mean/opt_rand_sd

opt_rand_summary <-data.frame(mean = opt_rand_mean, 
                              sd = opt_rand_sd, sr = opt_rand_sr)
row.names(opt_rand_summary) <- "opt_rand"

FANG_stats |>
  add_row(symbol = "opt_rand", opt_rand_summary) |>
  arrange(-sr)
```

The optimal portfolio <tt>`opt_rand`</tt> has a 0.4555797 return per unit of risk. This is clearly a better alternative compared with investing in individual assets as we show below.

A second criterion is to optimize according to ROI (R Optimization Infrastructure for linear and quadratic programming solvers).


```{r}
#| label: fig-frmop2
#| fig-cap: "FANG, ROI method optimal portfolio."
# Plot results.
chart.RiskReward(opt_roi, risk.col = "StdDev", 
                 xlim = c(0.05, 0.18),
                 return.col = "mean", rp = TRUE, chart.assets = TRUE)
points(0.05807856, 0.02645942, pch = 19, cex = 1.5, col = "black")
legend("bottomright", legend = c("ROI", "opt_rand"),
       col = c("blue", "black"), pch = 19, cex = 0.9)
```

A different optimization criterion leads to a different optimal portfolio. However, they are both optimal as they are in the efficient frontier.


```{r}
#| label: fig-frmow2
#| fig-cap: "FANG, ROI method optimal weights."
chart.Weights(opt_roi)
```

According to the <tt>`opt_roi`</tt> portfolio, we have to invest:

```{r}
extractWeights(opt_roi)
```


```{r}
opt_roi_mean <- as.numeric(extractObjectiveMeasures(opt_roi)$mean)
opt_roi_sd <- 
  as.numeric(extractObjectiveMeasures(opt_roi)$StdDev)
opt_roi_sr <- opt_roi_mean/opt_roi_sd

opt_roi_summary <-data.frame(mean = opt_roi_mean, 
                              sd = opt_roi_sd, sr = opt_roi_sr)
row.names(opt_roi_summary) <- "opt_roi"

FANG_stats |>
  add_row(symbol = "opt_rand", opt_rand_summary) |>
  add_row(symbol = "opt_roi", opt_roi_summary) |>
  arrange(-sr)
```
The optimal portfolio <tt>`opt_roi`</tt> has a 0.4244362 return per unit of risk. This is higher than the individual assets but lower than the <tt>`opt_rand`</tt> portfolio. According to the return per unit of risk, we should choose the <tt>`opt_rand`</tt> portfolio because it has a 0.4555797 return per unit of risk. The optimization process succeeds at proposing a better investment strategy compared with the individual assets. In practice, if you were interested to form a diversified portfolio, you could implement an analysis like this one, with some more extensive tests, but very similar to this analysis. As an individual, you could contact your broker or your financial institution at $t=0$ to ask them to invest your money according to the c portfolio: 28.2% in FB, 16.2% in AMZN, 7.4% in NFLX, and 47.2% in GOOG, and you should expect to get the <tt>`opt_rand`</tt> portfolio risky return at $t=1$.

The orange portfolio is also interesting as it represents an equally weighted portfolio. This is, 25% in each individual asset. We usually take this as a benchmark portfolio. You do not have to implement any optimization process to find out the 25% as it is basically $1/4$ or 1 over the number of assets. Interestingly, this equally weighted portfolio is close to being optimal but if you look closer, it is not optimal.

Let's take a closer look at the naïve portfolio. We have to define a new portfolio specification <tt>`port_naive`</tt> as we want to make sure the weights of the naïve portfolio are exactly 0.25.

```{r}
port_naive <- portfolio.spec(colnames(fang))
port_naive <- add.constraint(portfolio = port_naive, 
                             type = "full_investment")
port_naive <- add.constraint(portfolio = port_naive, 
                             type = "long_only")
port_naive <- add.objective(portfolio = port_naive,
                           type = "risk",
                           name = "StdDev")
port_naive <- add.objective(portfolio = port_naive,
                           type = "return",
                           name = "mean")
```

Now, compare the naïve portfolio with the rest.

```{r}
opt_naive <- equal.weight(fang, portfolio = port_naive)
opt_naive_mean <- as.numeric(extractObjectiveMeasures(opt_naive)$mean)
opt_naive_sd <- 
  as.numeric(extractObjectiveMeasures(opt_naive)$StdDev)
opt_naive_sr <- opt_naive_mean/opt_naive_sd
opt_naive_summary <-data.frame(mean = opt_naive_mean, 
                              sd = opt_naive_sd, sr = opt_naive_sr)
row.names(opt_naive_summary) <- "opt_naive"

FANG_stats |>
  add_row(symbol = "opt_rand", opt_rand_summary) |>
  add_row(symbol = "opt_roi", opt_roi_summary) |>
  add_row(symbol = "opt_naive", opt_naive_summary) |>
  arrange(-sr)
```
It may be disappointing to find out that the naïve portfolio <tt>`port_naive`</tt> has the higher Sharpe ratio including the optimal alternatives. We can add a target return constraint to the optimization problem so we can find out an optimal portfolio that targets the naïve portfolio expected return.

```{r}
port_spec2 <- add.constraint(portfolio = port_spec, type = "return", 
                             return_target = 0.03414333)
set.seed(13)
opt_roi2 <- optimize.portfolio(fang, portfolio = port_spec2,
                               optimize_method = "ROI", maxSR = TRUE,
                               rf = 0, trace = TRUE)
```


```{r}
#| label: fig-frmowtttnper
#| fig-cap: "FANG, ROI method optimal weights that targets the naïve portfolio expected return."
chart.Weights(opt_roi2)
```

According to the <tt>`opt_roi2`</tt> portfolio, we have to invest:

```{r}
extractWeights(opt_roi2)
```

```{r}
#| label: fig-frmtttnper
#| fig-cap: "FANG, ROI method that targets the naïve portfolio expected return."
# Plot results.
chart.RiskReward(opt_roi2, risk.col = "StdDev",
xlim = c(0.07, 0.073),
ylim = c(0.032, 0.036),
return.col = "mean", chart.assets = TRUE, cex = 2)
points(0.07176544, 0.03414333, pch = 19, col = "orange", cex = 2)
legend("bottomright", legend = c("opt_roi", "equally_weighted"),
col = c("blue", "orange"), pch = 19, cex = 0.8)
```

Now, compare the <tt>`opt_roi2`</tt> portfolio with the rest.

```{r}
opt_roi2_mean <- as.numeric(extractObjectiveMeasures(opt_roi2)$mean)
opt_roi2_sd <- 
  as.numeric(extractObjectiveMeasures(opt_roi2)$StdDev)
opt_roi2_sr <- opt_roi2_mean/opt_roi2_sd
opt_roi2_summary <-data.frame(mean = opt_roi2_mean, 
                              sd = opt_roi2_sd, sr = opt_roi2_sr)
row.names(opt_roi2_summary) <- "opt_roi2"

FANG_stats |>
  add_row(symbol = "opt_rand", opt_rand_summary) |>
  add_row(symbol = "opt_roi", opt_roi_summary) |>
  add_row(symbol = "opt_naive", opt_naive_summary) |>
  add_row(symbol = "opt_roi2", opt_roi2_summary) |>
  arrange(-sr)
```


The expected return in $t=0$ of the <tt>`opt_rand`</tt> portfolio is 0.02645942. The value of 0.02606294 is simply the sum of the <tt>`opt_rand`</tt> portfolio weights multiplied by the individual asset returns. But, what will be your realized return at $t=1$? Let's simulate the future $t=1$ to find out.

In this case, we invest in $t=0$ or 2016-12-30 and the future is $t=1$ or 2017-01-31. There are many ways to conduct the simulation. Let's keep it simple and use the historical mean and standard deviation information we have.

Let's simulate 1,000 observations of each individual asset and portfolios. We assume that the assets behave as a normal with mean and standard deviation as we show in the table above. This approach can be interpreted as if we were simulating 1,000 alternative values for 2017-01-31. By doing this, we could have a sense about what will be the most likely value at $t=1$.

```{r}
# Number of simulations.
sim = 1000
set.seed (7)
# Simulation per stock and portfolio.
s_AMZN <- rnorm(sim, 0.02566966, 0.08172605)
s_FB <- rnorm(sim, 0.03412852, 0.09894324)
s_GOOG <- rnorm(sim, 0.01757620, 0.05941703)
s_NFLX <- rnorm(sim, 0.05919893, 0.16656346)
s_ran <- rnorm(sim, opt_rand$opt_values$mean, opt_rand$opt_values$StdDev)
s_roi <- rnorm(sim, opt_roi$opt_values$mean, opt_roi$opt_values$StdDev)
```

The simulation is done. Now let's visualize the results in a boxplot. Boxplots show the distribution of the data in a data set. It divides the data set into three quartiles. This graph represents the minimum, maximum, median, first quartile and third quartile in the data set.

```{r}
#| label: fig-fsroia
#| fig-cap: "FANG, simulated returns of investment alternatives."
# The boxplot.
b = cbind(s_FB, s_AMZN, s_NFLX, s_GOOG, s_ran, s_roi)
boxplot(b, las = 2)
abline(h = 0, lty = 2)
```

Note that the <tt>`opt_rand`</tt> portfolio is well diversified and <tt>`opt_roi`</tt> is more risky. This plot reveals a glimpse to the future assuming that the assets follow a normal distribution. This assumption is not as bad and it is useful to simplify the analysis. Are we satisfied with this glimpse to the future? Sometimes it is the best you can have at $t=0$. In this case, we fortunately know what really happened with these stocks on 2017-01-31. Let's evaluate the returns that really happened at $t=1$ for the individual and portfolios.

First, we need the 2017-01-31 actual or realized returns. We need to download the data as the <tt>`FANG`</tt> database ends at 2016-12-30.

```{r}
# Download the 2017-01-31 individual asset returns.
r_stocks <- c("META", "AMZN", "NFLX", "GOOG") |>
  tq_get(get  = "stock.prices", from = "2016-12-31", 
         to   = "2017-01-31") |>
  group_by(symbol) |> 
  tq_transmute(select     = adjusted, 
               mutate_fun = periodReturn, 
               period     = "monthly", 
               col_rename = "R_stocks") |>
  tbl_xts(spread_by = "symbol")

r_stocks
```

These are the realized monthly returns at $t=1$. Please note that we have not introduced these returns before. Our model and portfolios ignores these returns. Now, we need to evaluate the realized return of both optimal portfolios. This is done by adding the multiplication of weights and individual realized returns. This approach is commonly known as out-of-sample evaluation.

```{r}
# Calculate realized portfolio returns.
realized_ret <- c(opt_rand = sum(opt_rand$weights * r_stocks),
                  opt_roi = sum(opt_roi$weights * r_stocks))

expected_ret <- c(opt_rand = opt_rand$opt_values$mean,
                  opt_roi = opt_roi$opt_values$mean)

data.frame(cbind(realized_ret, expected_ret))
```

In sum, the expected monthly return in $t=0$ of <tt>`opt_rand`</tt> portfolio is 0.02606294, and the realized monthly return in $t=1$ is 0.06958923. Not bad. The expected monthly return in $t=0$ of <tt>`opt_roi`</tt> is 0.04999645, and the realized monthly return in $t=1$ is 0.11390269. 

Let's see the whole thing now. This is, the distribution of the simulation and the realized returns in red.

```{r}
#| label: fig-fsroiawrhb2ir
#| fig-cap: "FANG, simulated returns of investment alternatives. What really happened by 2017-01-30 in red."
# The simulation.
boxplot(b, las = 2)
abline(h = 0, lty = 2)
# The realized returns in red.
points(1, 0.1208283,  col = "red", pch = 19, cex = 2)
points(2, 0.101782,   col = "red", pch = 19, cex = 2)
points(3, 0.1076947,  col = "red", pch = 19, cex = 2)
points(4, 0.02058163, col = "red", pch = 19, cex = 2)
points(5, sum(opt_rand$weights * r_stocks), col = "red", 
       pch = 19, cex = 2)
points(6, sum(opt_roi$weights * r_stocks),  col = "red", 
       pch = 19, cex = 2)
```

The realized returns can be quite different from the promised or expected returns. This difference depends on the method, the model, the database length, the ability of the portfolio designer, and also depends on a random component. In our <tt>`FANG`</tt> example, the optimal investment recommendations were good alternatives.

It is tempting to calculate an optimal portfolio based on our previous CAPM example. Let's do it here just to show how easy is it to replicate the analysis with a different database, which is the beauty of reproducibility as I basically did a copy paste of the previous code.

The data.

```{r}
# Download individual asset returns.
R_stocks <- c("NEM", "AMCR", "CLX", "PEAK", "KR", "TXN", "F", "TXT", 
              "KLAC", "TEF") |>
  tq_get(get  = "stock.prices", from = "2010-01-01", 
         to   = "2015-12-31") |>
  group_by(symbol) |> 
  tq_transmute(select     = adjusted, 
               mutate_fun = periodReturn, 
               period     = "monthly", 
               col_rename = "R_stocks")
R_stocks
```

The portfolio specification.

```{r}
capm_stocks <- R_stocks |> 
  tbl_xts(spread_by = "symbol") |>
  na.fill(fill = 0.00)

port_spec <- portfolio.spec(colnames(capm_stocks))
port_spec <- add.constraint(portfolio = port_spec, type = "weight_sum",
                            min_sum = 0.99, max_sum = 1.01)
port_spec <- add.constraint(portfolio = port_spec, type = "box", 
                            min = 0, max = 1)
port_spec <- add.objective(portfolio = port_spec,
                           type = "risk",
                           name = "StdDev")
port_spec <- add.objective(portfolio = port_spec,
                           type = "return",
                           name = "mean")
port_spec
```

The random method.

```{r}
#| label: fig-tarmop
#| fig-cap: "10-assets, random method optimal portfolio."
set.seed(13)
opt_rand <- optimize.portfolio(capm_stocks, portfolio = port_spec,
                          optimize_method = "random", trace = TRUE)
chart.RiskReward(opt_rand, risk.col = "StdDev", 
                 return.col = "mean", chart.assets = TRUE)
legend("bottomleft", legend = c("opt_rand", "equally_weighted"),
       col = c("blue", "orange"), pch = 19, cex = 0.8)
abline(0, opt_rand$objective_measures$mean /
         opt_rand$objective_measures$StdDev, lwd = 2, col = "red")
```

Here, the slope of the red line corresponds to the optimal portfolio return per unit of risk. This means that the optimal portfolio has a similar return per unit of risk compared with KR. Note how the rest of the assets have a lower return per unit of risk.

```{r}
extractWeights(opt_rand)
```

```{r}
#| label: fig-tarmopw
#| fig-cap: "10-assets, random method optimal weights."
chart.Weights(opt_rand)
```

Finally the ROI method.

```{r}
#| label: fig-tarmop2
#| fig-cap: "10-assets, ROI method optimal portfolio."
opt_roi <- optimize.portfolio(capm_stocks, portfolio = port_spec,
                          optimize_method = "ROI", trace = TRUE)
chart.RiskReward(opt_roi, risk.col = "StdDev", 
                 return.col = "mean", rp = TRUE, chart.assets = TRUE)
legend("bottomleft", legend = c("opt_roi"),
       col = c("blue"), pch = 19, cex = 0.8)
abline(0, opt_roi$objective_measures$mean /
         opt_roi$objective_measures$StdDev, lwd = 2, col = "red")

```
This is basically 100% in KR.

```{r}
extractWeights(opt_roi)
```

```{r}
#| label: fig-tarmow2
#| fig-cap: "10-assets, ROI method optimal weights."
chart.Weights(opt_roi)
```

## Diversification.

In finance, diversification is the process of allocating capital (or creating a portfolio) in a way that reduces the exposure to any one particular asset or risk factor. We usually recommend to invest in a variety of assets to achieve an overall risk reduction of our portfolio. However, if those assets are as correlated as Visa and Mastercard (as discussed before), then our diversification efforts would not be so effective. In this section, we propose an experiment to illustrate the role of diversification in asset allocation. The experiment is to artificially generate two assets and add them to the <tt>`FANG`</tt> database, so we end up with 6 assets. The special characteristic of these two new assets $X$ and $Y$ is that they both have a very extreme negative correlation value. Once we add these two assets, we will repeat the portfolio optimization and see if we could do better than before.

First, let's generate these two assets returns. Note that these two new assets $X$ and $Y$ do not exist in the real world, we are artificially generating them by implementing a simulation technique.

```{r}
set.seed(13)
data = mvrnorm(n = 48, mu = c(0.2, 0.5), 
               Sigma = matrix(c(1, -1.4, -1.4, 2), nrow = 2), 
               empirical = TRUE)/10
xy = as.data.frame(data)
X = xy$V1
Y = xy$V2
# Add X and Y to the fang database.
fang_xy <- fang
fang_xy$X <- X
fang_xy$Y <- Y
head(fang_xy)
```

Let's now verify that these two new assets are negatively correlated.

```{r}
cor(fang_xy)
```

The correlation of $X$ and $Y$ is −0.98994949, this is very close to −1, so they are strongly negatively correlated. This is just what we wanted. In fact, the correlation of these two new assets and the rest are also negative. In principle, we should expect a new optimal portfolio with a greater return per unit of risk.

Some may argue that investing in two inversely correlated assets would lead to a zero expected return. This is not the case as shown below.

Let's create a sequence of $X$ and $Y$ portfolio weights.

```{r}
w_x <- seq(0, 1, 0.01)
w_y <- 1 - w_x
```

Then, the two assets portfolio expected return and risk.

```{r}
ret_xy <- w_x * mean(fang_xy$X) + w_y * mean(fang_xy$Y)
sd_xy <- (w_x^2 * sd(fang_xy$X)^2 + 
          w_y^2 * sd(fang_xy$Y)^2 + 
          2 * w_x * w_y * sd(fang_xy$X) * sd(fang_xy$Y) *
            cor(fang_xy$X, fang_xy$Y))^0.5
```

```{r}
#| label: fig-taef
#| fig-cap: "2-assets, efficient frontier."
plot(sd_xy, ret_xy, type = "l", xlim = c(0, 0.15), ylim = c(0, 0.05),
     xlab = "Risk", ylab = "Expected return")
abline(v = 0, lty = 2)
abline(h = 0, lty = 2)
points(sd(fang_xy$X), mean(fang_xy$X), cex = 2, pch = 19, col = "red")
points(sd(fang_xy$Y), mean(fang_xy$Y), cex = 2, pch = 19, col = "blue")
legend("bottomright", legend = c("X", "Y"),
       col = c("red", "blue"), pch = 19, cex = 1)
```
Which is the minimum portfolio risk?

```{r}
min(sd_xy)
```
Which is the observation that match the minimum portfolio risk?

```{r}
which.min(sd_xy)
```

```{r}
#| label: fig-taefamvp
#| fig-cap: "2-assets, efficient frontier and minimum variance portfolio."
plot(sd_xy, ret_xy, type = "l", xlim = c(0, 0.15), ylim = c(0, 0.05),
     xlab = "Risk", ylab = "Expected return")
abline(v = 0, lty = 2)
abline(h = 0, lty = 2)
points(sd(fang_xy$X), mean(fang_xy$X), cex = 2, pch = 19, col = "red")
points(sd(fang_xy$Y), mean(fang_xy$Y), cex = 2, pch = 19, col = "blue")
points(sd_xy[60], ret_xy[60], cex = 2, pch = 19)
legend("bottomright", legend = c("X", "Y"),
       col = c("red", "blue"), pch = 19, cex = 1)
```
Which are the minimum variance portfolio weights?

```{r}
w_x[60]
w_y[60]
```

Now, consider the <tt>`FANG`</tt> database plus these two $X$ and $Y$ assets. Let's generate the portfolio specification and optimize our portfolio as we did before.

```{r}
# Create the portfolio specification
port_spec <- portfolio.spec(colnames(fang_xy))
port_spec <- add.constraint(portfolio = 
                              port_spec, type = "full_investment")
port_spec <- add.constraint(portfolio = port_spec, type = "long_only")
port_spec <- add.objective(portfolio = port_spec,
                           type = "risk",
                           name = "StdDev")
port_spec <- add.objective(portfolio = port_spec,
                           type = "return",
                           name = "mean")
# Optimization.
set.seed(13)
opt_xy <- optimize.portfolio(fang_xy, portfolio = port_spec,
                          optimize_method = "random", trace = TRUE)
```

We are done. Now, let's visualize the results.

```{r}
#| label: fig-fpxayrp
#| fig-cap: "FANG plus X and Y, random portfolio."
# Plot results.
chart.RiskReward(opt_xy, risk.col = "StdDev", 
                 xlim = c(0, 10),
                 return.col = "mean", chart.assets = TRUE)
points(0.05807126, 0.02606294, pch = 19, cex = 1.5, col = "black")
points(0.1170653,0.04960399, pch = 19, cex = 1.5, col = "red")
legend("topleft", legend = c("opt_xy (FANG+X+Y)", 
       "opt_rand (FANG)", "opt_roi (FANG)", "opt_naive (FANG)"),
       col = c("blue", "black", "red", "orange"), pch = 19, cex = 0.9)
```

This looks great as the new assets contribute to the optimization process to deliver a less risky portfolio. Now, the optimal portfolio has almost the same return as Facebook but with a significant reduced risk. Then, correlation value plays a determinant role in the diversification process. This is why investors are looking for low, or even better, negatively correlated assets.

Let's see the details of the new portfolio.

```{r}
# Extract weight, risk and return.
extractWeights(opt_xy)

opt_xy_mean <- as.numeric(extractObjectiveMeasures(opt_xy)$mean)
opt_xy_sd <- 
  as.numeric(extractObjectiveMeasures(opt_xy)$StdDev)
opt_xy_sr <- opt_xy_mean/opt_xy_sd

opt_xy_summary <-data.frame(mean = opt_xy_mean, 
                              sd = opt_xy_sd, sr = opt_xy_sr)
row.names(opt_xy_summary) <- "opt_xy"

FANG_stats |>
  add_row(symbol = "opt_rand", opt_rand_summary) |>
  add_row(symbol = "opt_roi", opt_roi_summary) |>
  add_row(symbol = "opt_naive", opt_naive_summary) |>
  add_row(symbol = "opt_roi2", opt_roi2_summary) |>
  add_row(symbol = "opt_xy", opt_xy_summary) |>
  arrange(-sr)
```

Note that the portfolio assigns high weights to $X$ and $Y$ with values of 52.2% and 43.4%. The rest is 0.2% in FB, 2.8% in AMZN, 0% in NFLX, and 1.4% in GOOG.


The <tt>`opt_xy`</tt> shows an impressive improvement. Informed investors are not looking for high return assets to invest in. Specially not in the context of portfolio investment. High return assets are associated with high risk so it is likely not to get the promised, or expected, return. Let me put a silly example. You buy a lottery ticket for 2 USD and you expect to win 1,000,000 USD, however the odds to win are 1 in 12,607,306. A 999,998 USD return looks quite nice but you will hardly get it. This is why we argue that we do not pick an asset with respect to its price, nor with respect to its return, but with respect to its return per unit of risk. In the context of asset allocation, this is partially why informed investors are not looking for high return assets to invest in, although this sounds like the popular thought. Investors can do better by selecting low correlated assets because this will allow them to form a well diversified portfolio with a more certain return at $t=0$. In sum, contrary to popular wisdom, we can argue that in many circumstances we are more interested in risk rather than in return. In fact, this topic is called *risk management*, not *return management*.

If you are not quite happy with the 2.645942% monthly return of <tt>`opt_rand`</tt> portfolio, you always have the <tt>`opt_roi`</tt> which is 4.999645% and still with a decent return per unit of risk. If this is still not good for you, then you should look to add an asset low or negatively correlated with your existing assets and conduct your optimization again. A good way to start looking at negative correlated assets is by looking at different and distant industries, or assets that belong to distant markets. This would at least improve the chances to find stocks with different responses to risk factors and this is a good way to start your search.

## Rebalancing portfolio and evaluation.

In the previous section we calculate portfolio weights once. We changed the optimization criteria and we added new assets, but we only calculate the portfolio weights once. Rebalancing is something very common in finance, it means to calculate portfolio weights as time passes. This makes sense because as time passes we have access to new information (stock returns) and we should re-balance our portfolio in order to take into account this new information. Evaluation is also a very common task in finance. We are interested to know what is the annualized return of an investment strategy in a period of time. In this section we are going to extend the asset allocation problem to incorporate rebalancing portfolio and evaluation. We are going to use a different database to illustrate our results.

Consider the following investment process. At $t=0$ I have access to 60 months historical information of a set of individual assets. Then, I can take information from $t=-60$ to $t=0$ to estimate optimal portfolio weights to form my portfolio at $t=0$. At $t=0$, $t=1$, and $t=2$ I simply get my returns or losses depending on the evolution of the market. Then, at $t=3$ I calculate new portfolio weights with information from $t=-57$ to $t=3$. At $t=3$, $t=4$, and $t=5$ I simply get my returns or losses depending on the evolution of the market. Then, at $t=6$ I calculate new portfolio weights with information from $t=-54$ to $t=6$. And I continue with the same procedure for several years. What would be my annualized return, and my annualized return per unit of risk? How could I know whether my investment procedure is better than other alternatives?

Before answering these questions, it is convenient to think in the process above. This looks like a lot of work. Everything starts with getting the price data for the correspondent assets. Then, convert the prices to returns. Then, calculate an optimal portfolio and implement the investment recommendation. Wait for the returns, and then re-balance our portfolio and implement the investment recommendation. Wait for the returns, and do the same until the end of the investment period which could last years. After that, look back to the portfolio returns and calculate an annualized return to evaluate my investment. This process is painful without a computer and without access to a computer language like R. In a computer we can automate this process and spend our time in more strategic tasks. Automatization is very common in other industries. Have you seen how cars are manufactured nowadays? You can hardly see a human operator, most of the process is made by robots. In finance, we can design robots since our main input is free data. Also, most of our main technology is free (R), the most expensive input is human capital.

Let's start with the data to tackle our objectives.


```{r}
# Get the data.
data(indexes)
returns <- indexes[, 1:4]
tail(returns)
```

The database goes from 1980-01-31 to 2009-12-31. The set of assets are: US Bonds, US Equities, Int'l Equities and Commodities. This means that the first investment recommendation is calculated with information from 1980-01-31 to 1985-01-31 (60 monthly observations), the second from 1980-05-31 to 1985-09-31, and so on until the last period that goes from 2009-09-31 to 2009-12-31. The first monthly return will be the one on 1985-01-31 and the last on 2009-12-31, these are 300 monthly portfolio returns.

Before calculating optimal portfolios, let's calculate a benchmark portfolio. This will allow us to compare our optimal portfolio with a benchmark. In this case the benchmark is simply an equally weighted portfolio, investing 25% in each asset for all the periods. This equally weighted portfolio implies that we will not conduct any optimization. It is like investing 25% in each asset (or index in this case) and doing nothing until the end of the investment period.

```{r}
# Equal weight benchmark.
n <- ncol(returns)
equal_weights <- rep(1 / n, n)
benchmark_returns <- Return.portfolio(R = returns, 
                                      weights = equal_weights,
                                      rebalance_on = "quarters")
colnames(benchmark_returns) <- "benchmark"
# Benchmark performance.
table.AnnualizedReturns(benchmark_returns)
```

We are interested in a benchmark because it would facilitate our evaluation task.

Now we define the portfolio specification as we did in the section before.

```{r}
# Base portfolio specification.
base_port_spec <- portfolio.spec(assets = colnames(returns))
#base_port_spec <- add.constraint(portfolio = base_port_spec,
#                                 type = "full_investment")
#base_port_spec <- add.constraint(portfolio = base_port_spec,
#                                 type = "long_only")
base_port_spec <- add.constraint(portfolio = base_port_spec, 
                                 type = "weight_sum", 
                                 min_sum = 0.99, max_sum = 1.01)
base_port_spec <- add.constraint(portfolio = base_port_spec, 
                                 type = "box", min = 0, max = 1)
base_port_spec <- add.objective(portfolio = base_port_spec, 
                                type = "risk", name = "StdDev")
```

We are ready to implement the investment process described before.

```{r}
# Run the optimization with periodic rebalancing.
opt_base <- optimize.portfolio.rebalancing(R = returns, 
            optimize_method = "ROI", portfolio = base_port_spec,
            rebalance_on = "quarters", training_period = 60, 
            rolling_window = 60)
# Calculate portfolio returns.
base_returns <- Return.portfolio(returns, extractWeights(opt_base))
colnames(base_returns) <- "base"
```

We are done. Rebalancing and evaluation are done. Now, let's show the results.

```{r}
#| label: fig-iow
#| fig-cap: "Indexes, optimal weights."
# Chart the optimal weights.
chart.Weights(opt_base)
```

This is how re-balancing looks like. It is the contribution of each asset in my portfolio. Clearly US bonds dominate my portfolio but this is what the optimization recommends. Now, let's see the annualized performance of this portfolio.

```{r}
# Merge benchmark and portfolio returns.
ret <- cbind(benchmark_returns, base_returns)
# Annualized performance.
table.AnnualizedReturns(ret)
```

We did better than our benchmark portfolio, that is good.

Something that happens frequently is that for some reasons we face constraints about how much money to invest in an individual asset. Let's assume this is the case and that we are supposed not to invest more than 40% in US bonds. We can incorporate this constraint easily and reproduce the re-balancing chart and annualized returns.

```{r}
# Make a copy of the portfolio specification.
box_port_spec <- base_port_spec
# Update the constraint.
box_port_spec <- add.constraint(portfolio = box_port_spec,
                                type = "box", min = 0.05, max = 0.4,
                                indexnum = 2)
# Backtest.
opt_box <- optimize.portfolio.rebalancing(R = returns, 
                                          optimize_method = "ROI",
                                          portfolio = box_port_spec,
                                          rebalance_on = "quarters",
                                          training_period = 60,
                                          rolling_window = 60)
# Calculate portfolio returns.
box_returns <- Return.portfolio(returns, extractWeights(opt_box))
colnames(box_returns) <- "box"
```

In principle, more constraints will lead to a worse solution. The optimization algorithm works better as long as it can freely choose portfolio weights.

```{r fig.cap="Indexes, optimal weights with box constraint."}
# Chart the optimal weights.
chart.Weights(opt_box)
```

Now, the rest of the assets have a more significant role in our portfolio.

```{r}
# Merge box portfolio returns.
ret <- cbind(ret, box_returns)
# Annualized performance.
table.AnnualizedReturns(ret)
```

As expected, more constraints negatively impact the possibilities to get a higher annualized return.

Most of these activities including providing investment recommendations in a regular manner are services offered by private firms. People looking to invest part of their money are supposed to receive assistance and guidance and many times it is in the form of an investment recommendation like the ones we calculate here. In the past, these services were provided only by those firms with access to the knowledge, capital, experience, and technology. Nowadays, there are an increasing number of fintechs that provide financial services because now we have access to powerful software and improved computational capabilities. In any case, functions like <tt>`optimize.portfolio()`</tt> are expected to be used as a tool by professionals and not as a pure source of investment recommendation.

```{r}
#| label: fig-ipp
#| fig-cap: "Indexes, portfolio performance."
charts.PerformanceSummary(R = ret)
```
