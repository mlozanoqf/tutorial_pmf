---
title: ''
output: pdf_document
---

# Financial data.

Data is everywhere and finance has always been about data.[^3] Industries perceive data as an essential commodity and fuel to take decisions under uncertainty. As a matter of fact, data science and finance go hand in hand. Even before the term data science was coined, finance was using it. Data Science is widely used in areas like risk analytics, credit risk, fraud detection, risk management, pricing, and algorithmic trading. Financial institutions were among the earliest users and pioneers of data analytics. We need data to perform financial analysis, estimate financial models, forecast financial variables, take financing and investment decisions, and more. The alternative of data is to listen to your guts, your intuition, or experience. This alternative is not bad by itself, but it would not be our main approach here.

[^3]: According to market intelligence company IDC, the 'Global Datasphere' in 2018 reached 18 zettabytes. The vast majority of the world's data has been created in the last few years and this astonishing growth of data shows no sign of slowing down. In fact, IDC predicts the world's data will grow to 175 zettabytes in 2025. One zettabyte is 1000000000000000000000 bytes. In scientific notation this is 1e+21 or 1 with 21 zeros at the right, we call it one sextillion.

Financial data is usually free and available in electronic sources for downloading. There are exemptions as private firms are not obligated to make their financial information public. Also, there are some kind of financial information that public firms are not obligated to make public given the international regulations. Sometimes, financial data is not fully available but we have summary statistics that can be quite useful to simulate the data by ourselves. Financial markets are a great source of financial information like exchange rates, commodities, financial instruments, etc. Public institutions and international organizations are useful sources of financial information as well. In any case, we have more financial data than time and resources to analyze it, and the gap is getting bigger and bigger.

## Financial statements.

Financial data comes in a wide variety of formats, and is reported and stored in numerous electronic sources. Financial statements represent a great source to analyze and understand the financial health of a firm, individuals and even governments. Financial statements are standard and well-organized reports that summarize important financial accounting information of a business. The traditional approach to analyze financial statements is looking at those in the firm's annual reports, or downloading them in PDF or Excel format in the firm's investor website site.

In R, we can download public firm's financial statements from the US Securities and Exchange Commission using the *finreportr* package (there are others like *finstr*). This is useful to evaluate a firm performance and conduct financial analysis as we do not need to visit the firm site. In fact, we could replicate or extend the full analysis by running the code instead of downloading newer financial statements.

In case you are not familiar with R packages, you should know you need to download the packages you need before using them. This is an easy process in RStudio. First, select the "Tools" menu, and then "Install Packages..." option. Now, type the name of the package you need, in this case type *finreportr* for accessing financial statements (later we will need *tidyquant* as well and others), leave the default options as they are, and click "Install". You will see a typical bar progress of this download process and R will let you know when this is done. You only need to download packages once, but you have to load the package (using the function *library*) every time you will use the package in your script. There are plenty of YouTube tutorials showing this installation process step by step, for example <https://youtu.be/JBcVi-fAT_k>

If you are interested in working with financial statements, you should look for the *finreportr* package documentation online or users' examples available in Internet. Perhaps the main drawback of this package is that it may be slow, you normally need to wait for R to download the financial reports. Let's start with some examples here. First, we load the previously downloaded packages.

```{r}
# Load the finreportr package to download financial reports.
library(finreportr)
# Load the tidyquant package to manipulate the data and more.
library(tidyquant)
library(dplyr)
library(tidyr)
```

Let's analyze Facebook.

```{r}
FB.Info <- CompanyInfo("FB")
print(FB.Info)
```

This is the physical address of the firm. Now some information about Facebook's annual reports.

```{r}
FB.reports <- AnnualReports("FB")
FB.reports$accession.no
```

These are keys to name specific financial reports. You can Google one of those keys above and see the kind of information available at SEC website. Now, let's download a balance sheet.

```{r}
# Store the balance sheet of Facebook (FB) in BS_FB.
BS_FB <- GetBalanceSheet("FB", 2018)
# Show the value in the screen (in paper).
BS_FB
```

We are done. We have the balance sheet information of Facebook in \texttt{BS\_FB} in basically two lines of code without even visiting the firm's website. However, it does not look the same as we are used to seeing in a typical format like PDF or Excel. To be honest, it is difficult to read to say the least. R takes the information from the annual report, so if we ask for 2018, we retrieve information for the previous years.

Let's review how we can manipulate \texttt{BS\_FB} contents to get a more readable result. Balance sheets are annual, so we do not need the *startDate* column, and we know it is expressed in US dollars, so we do not need the *Units* column as well. Imagine we are interested in a clear version of the 2017 balance sheet.

```{r}
# First make a copy.
BS_2017 <- BS_FB |>
  # convert Amount from character to numeric.
  mutate(Amount = as.numeric(Amount)) |>
  # Let's extract only 2017.
  filter(endDate == "2017-12-31") |>
  # Let's show only two columns.
  select(Metric, Amount)
# Show the value in the screen (in paper).
BS_2017
```

This looks more like a familiar balance sheet.

This is the first time we introduce the use of pipes |> in the code. Pipes are a powerful tool for clearly expressing a sequence of multiple operations mainly in the context of *tidyverse* packages. In the code above we first create a variable for the 2017 balance sheet \texttt{BS\_2017} as the same as the previously created variable \texttt{BS\_FB}, then we transform one column to numeric values so we can make further operations, then we filter the whole information to keep only 2017 values, and finally we select only two columns (the name and value of each account). There might be even more efficient ways to achieve the same result. Note that every sequence is linked with a pipe |>. Pipes process a data-object using a sequence of operations by passing the result of one step as input for the next step.

A balance sheet is a financial statement that reports a company's assets, liabilities and shareholders' equity. The balance sheet is one of the three (income statement and statement of cash flows being the other two) core financial statements used to evaluate a business performance. The balance sheet allows us to verify the so-called accounting equation: $assets = liabilities + equity$. This is equivalent as saying that the firm has what the firm owes.

In plain English the balance sheet shows the value of what the firm has to produce (assets), and where did the money come from (banks in the form of liabilities and/or owners in the form of equity). The balance sheet is used to measure the firm size, the evolution of the firm's debt, and the participation of the owners to finance the firm. It is also useful to measure firm's liquidity and credit risk, among many other things.

Let's extract the 2016 and 2017 balance sheets and show the most relevant rows to verify how the accounting equation holds.

```{r}
# Define the accounts we need in our balance sheet summary.
accounts <- c("Assets" , "Liabilities", 
              "Stockholders' Equity Attributable to Parent", 
              "Liabilities and Equity")
# At the beginning, the summary is a copy of the full statement.
BS_2016_2017_summary <- BS_FB |>
  # Convert Amount to numeric values (so we can do math operations).
  mutate(Amount = as.numeric(Amount)) |>
  # This is convenient but not strictly necessary.
  mutate(Metric = factor(Metric, levels = unique(Metric))) |> 
  # Here we spread rows into columns to have information per year.
  spread(endDate, Amount) |>
  # Select only three columns.
  select(Metric, "2016-12-31", "2017-12-31") |>
  # Select only the relevant accounts we are interested in.
  filter(Metric %in% accounts) |>
  # Net income account is lengthy, let's rename it.
 mutate(Metric = recode_factor(Metric, 
        `Stockholders' Equity Attributable to Parent` = "Equity"))
# Now, show the results.
BS_2016_2017_summary
```

As expected, the accounting equation holds in both 2016 and 2017. We were not expecting a different result. The purpose of this example is to show how we can download and manipulate financial statements of firms. As shown above, the only thing we need is the ticker symbol of the firm and voil√†. A ticker symbol or stock symbol is an abbreviation used to uniquely identify publicly traded firm shares. A stock symbol may consist of letters, numbers or a combination of both.

Looking at the USD values is difficult to have a gasp about which balance sheet account increased more or increased less in this period of time. This is, looking at absolute values (USD) makes it difficult to clearly see which account increased more than others, so we normally transform the data to relative terms (ratios, percentage changes, or proportions given a total).

Let's propose a different way to see the balance sheet statement.

```{r}
# First we make a copy.
BS_2016_2017_change <- BS_2016_2017_summary |>
  # Calculate the percentage change from 2016 to 2017.
  mutate(Year.Change = (`2017-12-31`-`2016-12-31`)/`2016-12-31`)
# Show the results.
BS_2016_2017_change
```

Liabilities increased more than twice compared with assets from 2016 to 2017. Should we be worried about Facebook financial health? One simple way to dig deeper into this issue is to show an alternative balance sheet showing the accounts as relative proportions with respect to the assets.

```{r}
# Create a copy of the summary.
BS_2016_2017_prop <- BS_2016_2017_summary |>
  # Proportions with respect to the assets (2016).
  mutate(prop2016 = `2016-12-31`/`2016-12-31`[1]) |>
  # Proportions with respect to the assets (2017).
  mutate(prop2017 = `2017-12-31`/`2017-12-31`[1])
# Show the results.
BS_2016_2017_prop
```

We are now less worried about the financial health of Facebook. Even though the liabilities increased about 76% from 2016 to 2017, these values are still low with respect to the firm's assets. In 2016 their liabilities were about 9% of their assets and 12% in 2017.

Let's plot.

```{r}
accounts_BS <- c("Assets" , "Liabilities", 
              "Stockholders' Equity Attributable to Parent")

BS_2016_2017_plot <- BS_FB |>
  mutate(Amount = as.numeric(Amount)) |>
  mutate(Date = as.Date(endDate)) |>
  mutate(Metric = factor(Metric, levels = unique(Metric))) |> 
  select(Metric, Amount, Date) |>
    filter(Date == "2016-12-31" | Date == "2017-12-31") |>
  filter(Metric %in% accounts_BS) |>
 mutate(Metric = recode_factor(Metric, 
`Stockholders' Equity Attributable to Parent` = "Equity")) |>
 mutate(Metric = 
           factor(Metric, levels = c("Assets", 
                                     "Liabilities", "Equity")))
BS_2016_2017_plot
```

Having the data as in \texttt{BS\_2016\_2017\_plot} makes it easier to use \texttt{ggplot}.

```{r}
library(ggplot2)
g <- ggplot(BS_2016_2017_plot, 
            aes(Metric, Amount, fill = Amount)) +
  ggtitle("Facebook - Balance sheet in USD") +
  geom_bar(stat = "identity") + 
  scale_fill_gradient(low = "red", high = "blue") +
  facet_wrap(~ Date)
g 
```

```{r eval=FALSE, include=FALSE}
# Para examen final.
g <- ggplot(BS_2016_2017_plot, aes(Amount/1000000, Metric)) +
  ggtitle("Facebook - Balance sheet in million USD") +
  geom_bar(col = "red", fill =  "white", stat = "identity") + 
  scale_x_continuous(labels=scales::dollar_format()) +
  facet_wrap(~ Date)
g 
```

Imagine all balance sheet accounts increased as in the case of Facebook, but the firm is losing money according to the income statement. In this case, we could say there is something wrong with Facebook. On the other hand, if these increases in the balance sheet accounts are supported by an increase in profits for the same period, then things are going well in the firm. Thus, we need Facebook income statement to verify the firm's profits and evaluate whether we should be worried about the increase in the liabilities.

Let's download the income statement and show only the revenues and profit for 2016 and 2017. Note that the process in R is basically the same as in the case of the balance sheet before. This is important as coding allows us to replicate or reproduce the analysis easily. As the process was recorded in the balance sheet, it is only a matter of adapting the same instructions to perform a similar manipulation for the income statement. You might see several lines of code but in reality, it is almost a copy-paste from the previous code. In fact, we are using the comments to emphasize that this code is not new, and is basically a copy of our previous procedure.

```{r}
# Define accounts just as we did before for the balance sheet.
accounts_IS <- c("Revenues" , 
  "Net Income (Loss) Available to Common Stockholders, Basic")
# Instead of GetBalanceSheet, we use GetIncome.
IS_FB <- GetIncome("FB", 2018)
  # Make a copy (as before).
IS_2016_2017_summary <- IS_FB |>
  # Exactly the same as before.
  mutate(Amount = as.numeric(Amount)) |>
  # Exactly the same as before.
  mutate(Metric = factor(Metric, levels = unique(Metric))) |> 
  # Select the required columns.
  select(Metric, Amount, endDate) |>
  # Exactly the same as before.
  spread(endDate, Amount) |>
  # Exactly the same as before.
  select(Metric, "2016-12-31", "2017-12-31") |>
  # Similar as before.
  filter(Metric %in% accounts_IS) |>
  # Similar as before.
  mutate(Metric = recode(Metric, 
  `Net Income (Loss) Available to Common Stockholders, Basic` 
  = "Net Income"))
# Similar as before.
IS_2016_2017_summary
```

In this code above we explicitly repeat how many times we reproduce the same or very similar code as we did in the case of the balance sheet. This is because it is important to highlight that coding allows us to reproduce our analysis easily. Imagine you are interested to compare balance sheet and income statements for 5 companies using a software that requires using the mouse to click on pre-defined menus. In that case you will have to repeat the procedure step by step and hope to remember so you do not skip anything. In R we code so our procedure is recorded in a series of instructions. Now consider that you need to add two accounts to your analysis. In that case you will only have to change this line:

```{=tex}
\texttt{accounts\_IS <- c("Revenues" , 
"Net Income (Loss) Available to Common Stockholders, Basic")}
```
and add a third or fourth account name and that's it.

Now we have the relevant information we need. The profits increased more than 50% from 2016 to 2017, so apparently the firm knows how to make money. The new asset investments allow the firm to increase the profits. We can calculate a simple financial ratio to find out the relationship between assets (in the balance sheet, representing the firm investment) and profits (in the income statement, shows the ability of the firm to make money). A financial ratio or accounting ratio is a relative magnitude of two selected numerical values taken from an enterprise's financial statements. There are many standard ratios used to try to evaluate the overall financial condition of a corporation.

-   $AP_{2016} = 6.4961/1.0188 = 6.376227$
-   $AP_{2017} = 8.4524/1.5920 = 5.309296$

We normally are interested in making these calculations automatically, without copying the values and taking them directly from the correspondent variables:

```{r}
BS_2016_2017_summary[1,2] / IS_2016_2017_summary[2,2]
BS_2016_2017_summary[1,3] / IS_2016_2017_summary[2,3]
```

$AP_{2016}$ and $AP_{2017}$ represent the ratio of assets and profits for 2016 and 2017. Then, the firm requires 6.38 USD asset investment to make 1 USD in profits in 2016 and only 5.31 USD in 2017. We can also view the same thing the other way around, this is profits over assets. If we do this, then the firm makes 0.1568326 USD for every dollar invested in the asset in 2016 and 0.1883489 USD in 2017. This is clearly good news as the firm's assets are more productive according to this simple analysis.

Let's calculate the revenues with respect to profits.

```{r}
# Make a copy.
IS_2016_2017_prop <- IS_2016_2017_summary |>
  # Calculate proportion (2016).
  mutate(prop2016 = `2016-12-31`/`2016-12-31`[2]) |>
  # Calculate proportion (2017).
  mutate(prop2017 = `2017-12-31`/`2017-12-31`[2])
# Show results.
IS_2016_2017_prop
```

According to this ratio, in 2016 the firm transformed 2.7 USD of sales into 1 USD profit, and in 2017 the firm required only 2.5 USD. Accounting ratios like this one can be used for financial managers as corporate targets or firm's objectives. Imagine most of the rest of the firms in the same industry only need 2 USD to generate 1 USD profit. In that case, the financial manager might propose an objective for next year to reduce costs so they can transform 2 USD sales into 1 USD profits for the next year.

Let's plot the income statement basics. First, some necessary changes.

```{r}
IS_2016_2017_plot <- IS_FB |>
  mutate(Amount = as.numeric(Amount)) |>
  mutate(Date = as.Date(endDate)) |>
  mutate(Metric = factor(Metric, levels = unique(Metric))) |> 
  select(Metric, Amount, Date) |>
  filter(Metric %in% accounts_IS) |>
  mutate(Metric = recode(Metric, 
  `Net Income (Loss) Available to Common Stockholders, Basic` 
  = "Net Income"))
IS_2016_2017_plot
```

Now, a nice plot.

```{r}
library(ggplot2)
g <- ggplot(IS_2016_2017_plot, 
            aes(Metric, Amount, fill = Amount)) +
  ggtitle("Facebook - Income statements in USD") +
  geom_bar(stat = "identity") + 
  scale_fill_gradient(low = "red", high = "blue")+
  facet_wrap(~ Date)
g
```

This is why we are interested firms to perform well in the economy. If firms are well managed, they are expected to take good strategic decisions to increase the value of the firm. In particular, the firm looks for funds from banks or owners, then invests in assets to produce or provide a service to the market. If things go well, sales increase and if revenues are greater than costs, the firm makes profits. When the firm increases their assets, they might also need more people to produce or manage those assets, then employment increases. More jobs mean more families with available income, and families will spend their income and stimulate the whole economy further. Even government may increase their tax revenues to (hopefully) spend them into high-quality public goods to increase society's welfare. Not only that, as a firm performs well, the whole value chain straightens as the firm requires inputs and services from other firms to operate. We are interested firms to perform well in the economy because that is good for the population in general and to other firms as well. Private investment stimulates the whole economy.

Strictly speaking, firms (regardless of their size) do not own what they have. Firm's assets were originally bought or financed using others' money (liabilities) and/or owners' money (equity). In simple terms, people are interested to finance the firm activities because the firm is supposed to know how to invest those funds in productive assets to make profits as in the case of Facebook. When the financial statements show that firms take bad decisions, their assets do not produce profits and people will not be very interested in financing a non-profitable firm. In good times, people who finance productive firms receive interests, returns, or dividends as a compensation for putting their money at risk.

Firms have incentives to be and keep being financially healthy in the future to attract financing more easily. Public firms (as those participating in the stock market) are subject to strict regulations and public scrutiny so everybody can constantly evaluate the firm performance. Regulations do not prevent all frauds or bankruptcies, but they are intended to minimize irregular and illegal practices. We were able to freely download financial statements because regulators ask public firms to do so given some deadlines and specific guidelines. Yearly and quarterly financial statements are analyzed in detail to evaluate firms as projects, and the main interest is the relationship between risk and return, so people can make better investment decisions. The decision of financing a firm operation is risky, but the reward is supposed to be attractive enough to compensate that risk. In finance we are interested to measure how risky are the investment opportunities in the form of firms, projects, and financial assets in general. When we do a financial analysis, we also compare the performance of one company not only with respect to previous years, but also with respect to other firms, and also with respect to their own industry or sector. This is not difficult as the regulators ask public firms to publish their financial statements in a similar manner, so comparisons among different firms are valid.

Finance is about people taking decisions under uncertainty with the help of data analysis. Think in two kind of people in the world: those who have money but no ideas (investors), and those who have ideas but no money (firms or entrepreneurs). We refer to ideas as business ideas, innovations, business projects that require funds to get started. Those with ideas and money are rare in this world, and those without ideas and without money are in trouble. When the financial system works well, productive projects will succeed at attracting funds, firms will invest in productive assets, private investment grows, and we should expect economic growth, and hopefully economic development improves. When the financial system fails, good projects might fail to get funding and probably bad projects get financing. This could be frustrating.

People with money and no ideas are looking for opportunities for their money to grow. They basically face two alternatives: to save their money (put it in the bank and receive a small but certain return), or invest their money in risky projects offered by firms or entrepreneurs. The final decision is taken based on a risk-return analysis, with the help of data analysis and financial models. Imagine the bank offers a secure 4%, and the firm offers a risky 3.5% return (assume it could be as low as ‚àí1% or as high as 4%). In that case, most of us might agree (if you are risk averse as me) that the funds are better in a bank. Now assume a different situation. The bank offers a secure 4%, and the firm offers a risky 6% return (it could be as low as 3.5% and as high as 8%). In that case, there might be some investors that after doing some analysis finally decides to put their money at risk. Things become interesting and complex because the same project can be attractive for some investors and bad for others as they might have different tools to analyze risky projects and they might also have different risk appetite levels.

People with ideas but no money are looking for funds to run their projects. If the project is impressively good, then the firm could ask for funds in exchange of a reduced return. The project is then not too risky and the return is also low. On the other hand, if the project looks OK but entails a high risk, the firm or entrepreneur should be willing to pay high returns to investors to compensate for the associated risk. This is why risk and return move together, the higher the risk the higher the return and vice-versa. If this rule fails, then we are in trouble.

Interestingly, an excess of private investment is not always good for the economy. Imagine the interest rate (return of savings, and the cost of asking for a loan) is low and the economic perspectives look good. In that case, we have good conditions for the private investment to grow as it is cheap to ask for financing. In the extreme, families now have more money and they start spending a lot. Aggregate demand for all goods and services increase and consequently the prices of all goods and services increase as well. The country is experiencing an increase in the inflation levels. Then, even though people have money in their pockets, they are not able to buy as prices increase faster than families' income. In order to reduce inflation levels, the monetary authority increases the interest rates, making savings more attractive and investment less attractive. If they succeed, people will spend less and save more. This decreases the aggregate demand for goods and services and prices could decrease again to desired levels. To add more drama, imagine that this increase in interest rates is so high that now economic growth is slowing down and the risk of falling into a recession increase. If that happens, then the monetary authority should decrease the interest rates again to incentive people to stop saving and start investing again. This is why you see that interest rates go up and down, although we have had low interest rates for a while.

Let's go back to finance and illustrate the process of a firm looking for funds, the difference between private and public firms, and see how a firm can grow or go bankrupt in a simple but illustrative example.

Firms can sell bonds or stocks as a way to get funds. Let's focus on the stocks. By selling stocks, the firm can increase their equity and consequently increase their assets. People who buy stocks expect the firm to make wise investment decisions to get a return in the future. Initially, in time zero $t=0$, assume the firm is private and has the following balance sheet:

```{r}
# The firm is private now. 
private_firm_bs <- c(assets = 100, liabilities = 40, equity = 60)
# Print results.
private_firm_bs
```

Private firms cannot sell stocks in the stock market, only public firms can. Selling stocks in the stock market is attractive for some firms because it is a way for them to grow. Stock markets allow more participant firms as long as they fulfill some strict requirements. Given the balance sheet above, the owner of this private firm invested 60 USD. When the firm goes 100% public, then the owner will sell the 60 USD investment to others.

In $t=1$, with the objective of getting fresh funds, the firm decides to go 100% public and sell 60 stocks at 1 USD each. Imagine that the firm succeeded at selling all 60 stocks at 1 USD. This is because investors who participate in the stock market consider that this is a fair value for the firm. These investors become new owners; this is why we say the firm is now public. So, by the end of $t=1$ we have:

```{r}
# The firm is public now. 
public_firm_bs <- c(assets = 100, liabilities = 40, 
                    equity_60x1 = 60)
# Print results.
public_firm_bs
```

In $t=2$ more investors realize that the firm is well managed, its market is growing and there is no close competition. Now, investors actually think that paying 1 USD per stock is actually a bargain, so they are willing to pay even more than 1 USD to participate in this project. So, the demand for those stocks increases, and as a result the price goes from 1 to 2 USD per share. By the end of $t=2$ we have:

```{r}
# Stock price increased from 1 to 2.
public_firm_bs <- c(assets = 100+60, liabilities = 40, 
                    equity_60x2 = 120)
# Print results.
public_firm_bs
```

Now the firm has grown by going public and by showing good perspectives.

However, in $t=3$ we sadly get to know that the firm's financial statements were overestimating profits, and a big fraud was detected today. Big scandal and all newspapers talk about it. Then, investors are now interested in selling all their stocks as quickly as they can. Investors are so desperate to sell their stocks that they drop the stock price to almost zero. By the end of $t=3$ we have:

```{r}
# Stock price decrease to 0.
public_firm_bs <- c(assets = 40, liabilities = 40, 
                    equity_60x0 = 0)
# Print results.
public_firm_bs
```

There are still 60 stocks in the market with a unit price of zero, so the market value of equity is null. This hypothetical firm is virtually bankrupt as they need to sell all their assets to pay the debt. In simple terms, a firm is bankrupt when the liabilities are greater than the assets. The firm will hardly get fresh funds as investors realize this was a bad project.

Many things can happen when a firm faces this difficult situation. Sometimes it is worthwhile to try to improve the firm's financial condition, hiring professional managers, and hope to recover the investor's confidence. Before bankruptcy, firms could also negotiate with their debt holders. If negotiation succeeds, the firm could get a longer debt maturity, a reduced debt to help the firm remain alive and hope to recover its operations, or a more innovative solution. There are also other firms that look for firms in trouble to buy them for a wide variety of reasons. In the US, you may hear about "Chapter 11", which is a form of bankruptcy that involves a reorganization of a debtor's business affairs, debts, and assets, and for that reason is known as "reorganization" bankruptcy. Corporations generally file Chapter 11 if they require time to restructure their debts. This version of bankruptcy gives the debtor a fresh start. However, the terms are subject to the debtor's fulfillment of its obligations under the plan of reorganization.

As we show before, the stock price evolution is generally a good indicator about how the investors interpret the future of the firm. When the stock price increases, then investors are demanding more stocks. A higher stock price is associated with a more valuable equity and this is good for the firm. When the stock price decreases, then there are more people trying to sell stocks compared to those trying to buy so the stock price falls. There might be some cases in which a drop in the stock price is associated with a firm good performance. Consider the stock price has increased in the last week, investors bought at 10 USD and today's price is 15 USD. Those investors might be interested to sell now to make a 5 USD profit. This increase in the supply of stocks could be significant enough to drop prices in the short run.

Remember this firm needed to go public before issuing and selling stocks in the stock market. Normally, these firms are big, although there are some stock markets for medium-sized firms. Small firms can hardly access these kinds of markets to get funding in a direct way. This might be problematic because small firms are the ones which require more alternatives to get financing so they can grow. The literature regarding small firms show that one of the most important problems they face is precisely the lack of financing or the limited alternatives to get funds. This remains an open challenge for the financial services and an opportunity for fintech companies. In the world there are significantly more small firms compared with big firms, so any improvement in the credit conditions of small firms could have a significant impact on the income of many people.

In the following section we move from a financial statement analysis to the analysis of stock prices. Note that both are linked by the equity and overall performance of public firms.

## Stock prices and other financial data.

Financial markets not only facilitate financial transactions between sellers and buyers, they also represent a rich source of financial data. Here, we show how to use R to download stock price data from financial markets by using a few examples.

R packages like *quantmod* and *tidyquant* make the process of downloading financial data to perform financial analysis very straightforward. The *quantmod* package for R is designed to assist the quantitative trader in the development, testing, and deployment of statistically based trading models. The *tidyquant* package is part of the so-called *tidyverse*, an opinionated collection of R packages introduced by Hadley Wickham and designed for data science. All *tidyverse* packages share an underlying design philosophy, grammar, and data structures.

In the past, when we were interested in performing a financial analysis in a rudimentary statistical software, we had to open the financial market site, download the data in Excel or text format, and then convert it to a compatible format given the statistical software requirements. In ancient times, people had to gather financial data from the newspaper. Fortunately for us, now we have R packages to make this process not only easy but also free, extremely efficient and immediate.

Let's download Apple stock prices in one step (we already loaded the *tidyquant* package as step zero).

```{r}
# Get stock prices for Apple stock from Yahoo! finance site.
aapl_stock_prices <- tq_get("AAPL")
```

We are done. The special variable \texttt{aapl\_stock\_prices} contains Apple stock prices and other relevant information. Many things happened here in a very few steps. First, we need to have Internet access, R and R Studio working on our computer. Then, we load the *tidyquant* package. This package presumably integrates the best resources for collecting and analyzing financial data in R. The \texttt{tq\_get} function belongs to the *tidyquant* package, and *tidyquant* belongs to the *tidyverse* packages. Specifically, \texttt{tq\_get} connects to a default financial site, which in this case is the finance.yahoo.com and looks for the "AAPL" symbol which corresponds to Apple Inc. (an American multinational technology company). Finally, we store the data into \texttt{aapl\_stock\_prices}.

To see what it is inside the \texttt{aapl\_stock\_prices} object we can do the following.

```{r}
# str function is a way to display the structure of an R object.
str(aapl_stock_prices)
```

According to the \texttt{str} output, \texttt{aapl\_stock\_prices}, we have `r nrow(aapl_stock_prices)` daily observations for 7 variables. As you can see, we have not only prices but also volume. Let's consider a different way to see and have a grasp of what it is inside \texttt{aapl\_stock\_prices}. In particular, we can see the first and the last part of this lengthy daily database.

The first observations.

```{r}
# See the first observations of aapl_stock_prices.
head(aapl_stock_prices)
```

The last observations.

```{r}
# See the last observations of aapl_stock_prices.
tail(aapl_stock_prices)
```

By default, the \texttt{tq\_get} function downloads the latest set of data available. You can verify that the last date of \texttt{aapl\_stock\_prices} above approximately corresponds to the production date of this tutorial. If there is a difference it is simply because the stock market is still close or we are running the code in a weekend. In this case:

-   Last \texttt{aapl\_stock\_prices} observation: `r aapl_stock_prices$date[length(aapl_stock_prices$date)]`.
-   Today is: `r Sys.Date()`.

We also like to show the data in a plot.

```{r}
# Date is in the x axis, price in the y axis. The type l stands for line.
plot(aapl_stock_prices$date, aapl_stock_prices$adjusted, 
     type = "l")
```

We can add a few instructions to improve the format of our plot.

```{r}
# x and y labels, the title, and the color of the line.
plot(aapl_stock_prices$date, aapl_stock_prices$adjusted, 
     type = "l",
     xlab = "Date", ylab = "Adjusted price", 
     main = "Apple stock price", col = "blue")
```

We can compare Apple versus a stock index like S&P500.

```{r}
# Download the S&P500 index.
SP <- tq_get("^GSPC")
```

Plot both assets together.

```{r}
par(mar = c(5, 5, 2, 5))
plot(SP$date, SP$adjusted, type = "l", col = "red",
     ylab = "Standard and Poors 500 index",
     xlab = "Date", 
     main = "Index and stock 2011-01-03 to 2021-03-05")
par(new = T)
plot(aapl_stock_prices$date, aapl_stock_prices$adjusted, 
     type = "l", axes = F, xlab = NA, ylab = NA, cex = 1.2)
axis(side = 4)
mtext(side = 4, line = 3, "Apple stock price")
legend("topleft",
       legend=c("SP500", "Apple"),
       lty = 1, col = c("red", "black"))
```

Let's continue with the Apple stock analysis. Stock prices change throughout the trading day. This is, the open price changes every minute (sometimes in milliseconds), so the open price is normally different from the closing price. We can calculate the difference between the high and low price of each day and then show the result in a plot.

```{r}
# Create a new variable.
aapl_diff = aapl_stock_prices$high - aapl_stock_prices$low
# Plot the new variable.
plot(aapl_stock_prices$date, aapl_diff, type = "h",
     xlab = "Date", 
     ylab = "Difference between high and low prices", 
     main = "Apple's stock price can change about $25 in one day",
     col = "blue")
```

The difference between high and low prices show that the stock price changes during a trading day. These changes can be considerably high. Moreover, this volatility has increased in recent times. Is it possible to know the exact date in which this difference is the highest? One alternative is to sort all observations, but there is a simpler approach.

```{r}
# Which observation has the maximum value of aapl_diff?
highest_change = which.max(aapl_diff)
# Show results.
highest_change
```

Consider the value of \texttt{highest\_change} as an index. This is, the number of the row that contains the highest \texttt{aapl\_diff} value. We can use this index to extract the date and the actual \texttt{aapl\_diff} value.

```{r}
# Now, extract the date and the actual value of aapl_diff.
# See how brackets [] are used to extract a single row value.
when = aapl_stock_prices$date[highest_change]
top = aapl_diff[highest_change]
```

The output above shows when (in the variable \texttt{when}) Apple stock had its highest price change (\texttt{top}) in one day.

```{r}
# We can use when and top variables to improve our plot.
plot(aapl_stock_prices$date, aapl_diff, type = "h",
     xlab = "Date", 
     ylab = "Difference between high and low prices", 
     main = "Apple's stock price can change about $12 in one day",
     col = "blue")
# Here, we add the red point.
points(when, top, pch = 19, col = "red", cex = 1.5)
```

Up to know, we have been using default options as we simply ask for stock prices of Apple without any other kind of instruction. As a result, we get data starting from 2010: \texttt{tq\_get("AAPL")}. However, we can change default options if needed to get data back to 1990. I will take some online available examples developed by the author of *tidyquant* Matt Dancho.

```{r}
# Download Apple stock prices.
aapl_prices  <- tq_get("AAPL", get = "stock.prices", 
                       from = " 1990-01-01")
# Show results.
aapl_prices
```

Sometimes we are interested in periodicity aggregation from daily to monthly. We cannot transform from monthly to daily, but we can always transform from daily to monthly, monthly to yearly and so on. FANG is a dataset containing the daily historical stock prices for the "FANG" tech stocks, "FB", "AMZN", "NFLX", and "GOOG", spanning from the beginning of 2013 through the end of 2016.

Let's aggregate data from daily to monthly frequency.

```{r}
# Here, we are using a pre-loaded dataset.
data("FANG")
# Transform from daily to monthly stock prices.
FANG |>
    group_by(symbol) |>
    tq_transmute(select = adjusted, mutate_fun = to.monthly, 
                 indexAt = "lastof")
```

The *tidyquant* package can also access other kinds of data from diverse sources like the Federal Reserve Economic Data (FRED). Federal Reserve Economic Data is a database maintained by the Research division of the Federal Reserve Bank of St. Louis that has more than 765,000 economic time series from 96 sources. Consider the WTI Crude Oil Prices.

```{r}
# See https://fred.stlouisfed.org/series/DCOILWTICO
# Download oil prices from FRED.
wti_price_usd <- tq_get("DCOILWTICO", get = "economic.data")
# Show results.
wti_price_usd
```

Now that we have oil prices in basically one single step, we can plot them. It is interesting because recently the oil prices have turned negative in one day. Negative prices are rare but not impossible, especially in commodities.

```{r}
# ggplot2 is a system for creating graphics see https://amzn.to/2ef1eWp.
library(ggplot2)
# Create a simple line plot to show the oil price evolution.
ggplot(wti_price_usd, aes(date, price)) + 
  geom_line() + theme_bw() +
geom_hline(yintercept = 0, linetype = "dashed", color = "red")
```

It is easy to find out the exact day when the oil price was negative.

```{r}
# Extract one row given a condition.
subset(wti_price_usd, price < 0)
```

Without going into technical arguments, we can interpret negative prices as the following. Imagine (as it actually happened) that storing oil is expensive, not only that, imagine oil producers have no further physical space to store oil, so they are desperate to get rid of the oil production. On the other hand, oil buyers realize that the economic perspectives in the world look bad. If the economic activity suddenly stops, then we expect a lower demand for fuel including oil as firms are producing less. Then, producers want to sell and buyers are not interested to buy as they do not need as countries have more than enough inventories. This could go to the extreme in which producers are (sadly) willing to pay people in exchange of taking the oil out of their hands. This is why commodity prices can be negative.

There are other explanations, for example one related to the maturity of oil futures contracts. The price that went negative on Monday 2020-04-20 was for futures contracts to be delivered in May. Those contracts expired on Tuesday 2020-04-21. Upon expiration of the futures contract, the clearinghouse matches the holder of a long contract against the holder of a short position. The short position delivers the underlying asset to the long position. So, on Monday, traders --- who were not equipped to take physical deliveries --- were rushing to sell them to buyers who have booked storage.

The *quantmod* package can retrieve exchange rates easily.

```{r}
# Load the package.
library(quantmod) 
# Download USD/MXN exchange rate from Oanda site.
exchange_rate <- getSymbols("USD/MXN", src = "oanda", 
                            auto.assign = FALSE)
# Plot the results.
plot(exchange_rate)
```

Here, 1 USD equals `r last(exchange_rate)` MXN as `r Sys.Date()`. We can show the time series information into a density plot.

```{r}
# Density plots.
ggplot(exchange_rate, aes(x = USD.MXN, fill = "")) +
  geom_density(alpha = 0.8) +
  geom_hline(yintercept = 0, color = palette_light()[[1]]) +
  labs(title = "USD.MXN", x = "USD.MXN", y = "Density") +
  theme(legend.position = "none", legend.title = element_blank()) +
  scale_fill_tq()
```

We can conveniently download the data directly from the FRED API. Let's see data of "Beer, Wine, and Distilled Alcoholic Beverages Sales". For the full database details see:

<https://fred.stlouisfed.org/series/S4248SM144NCEN>

```{r}
# Beer, Wine, Distilled Alcoholic Beverages, in Millions USD
beer_sales_tbl <- tq_get("S4248SM144NCEN", get = "economic.data", 
                         from = "2010-01-01", to = "2021-01-01")
```

Let's have a look at the data set. By default, it says *price*, but these are basically sales figures. According to the main FRED reference, these are in millions of dollars, not seasonally adjusted.

```{r}
# See part of the data.
glimpse(beer_sales_tbl)
```

Visualization is particularly important for time series analysis and forecasting. It is also important to see the time series because normally the models will perform better if we can identify time series basic characteristics such as trend and seasonality. This data set clearly has a trend and a seasonality.

```{r}
# Plot the data.
beer_sales_tbl |>
  ggplot(aes(date, price)) + 
  geom_line(col = palette_light()[1]) +
  geom_point(col = palette_light()[1]) + theme_tq() +
  scale_x_date(date_breaks = "1 year", date_labels = "%Y") +
  labs(title = "Beer Sales: 2010 through 2020.") 
```

A time series can be decomposed as shown below.

```{r}
library(fpp3)

stl_dcmp <- beer_sales_tbl |> 
  mutate(date = yearmonth(date)) |>
  as_tsibble(index = date)

stl_dcmp |>
  model(STL(price ~ trend(window = 7) + 
              season(window = "periodic"), robust = TRUE)) |>
  components() |>
  autoplot()
```

We can also create some interesting visualizations about US employment and the US recessions (in the shaded area) over time. The code below is not so compact but it works.

```{r}
# NBER Recession indicator and US nonfarm payroll employment
tickers<- c("USREC", "PAYEMS")
df <- tq_get(tickers, get = "economic.data", from = "1948-01-01")
# recession df (for plotting)
recessions.df = read.table(textConnection(
  "Peak, Trough
  1945-02-01, 1945-10-01
  1948-11-01, 1949-10-01
  1953-07-01, 1954-05-01
  1957-08-01, 1958-04-01
  1960-04-01, 1961-02-01
  1969-12-01, 1970-11-01
  1973-11-01, 1975-03-01
  1980-01-01, 1980-07-01
  1981-07-01, 1982-11-01
  1990-07-01, 1991-03-01
  2001-03-01, 2001-11-01
  2007-12-01, 2009-06-01
  2020-02-01, 2021-01-30"), sep = ',', 
  colClasses = c('Date', 'Date'), header = TRUE)
rec3 <- filter(df, df$symbol == "PAYEMS")
my_trans <- function(in.data,transform = "pctdiff3") {
  switch(transform, logdiff  = c(NA, diff(log(in.data))),       
         pctdiff3 = 100 * Delt(in.data, k = 3),
        logdiff3 = c(rep(NA, 3), diff(log(in.data), 3)))
}
vlist <- c("PAYEMS")
df2 <- df |> group_by(symbol) |>
  mutate(x = ifelse(symbol %in% vlist, my_trans(price), price))
df2 |> select(-price)  |> spread(symbol, x) |>
  mutate(REC12 = lead(USREC, 12)) -> df3              
df41 <- filter(df3, year(date) > 1945)
```

We have the data, now we can plot.

```{r}
ggplot(data = df41, aes(x = date, y = PAYEMS)) + 
  geom_rect(data = recessions.df, inherit.aes = FALSE,
            aes(xmin = Peak, xmax = Trough, 
                ymin = -Inf, ymax = +Inf), 
            fill = 'black', alpha = 0.5) + theme_minimal() + 
  geom_line(color = "red", size = 1.5) + 
  labs(x = "", y = "", 
       title = "US employment growth and recessions.",
       subtitle = "Last value: December 2020. Shaded area are NBER recessions.", 
       caption = "Source: US Bureau of Labor Statistics.
       \nretrieved from FRED, Federal Reserve Bank of St. Louis.") + 
  geom_hline(yintercept = 0) +
  geom_vline(xintercept = as.numeric(as.Date("2020-12-01")), 
             type = 3) +
  theme(plot.caption = element_text(hjust = 0),
        plot.subtitle = element_text(face = "italic", size = 9),
        plot.title = element_text(face = "bold", size = 14))
```

Here we can see the magnitude of the current and upcoming financial and economic crisis. The fall in the US employment is impressive as you can see. Note how recessions (gray bars) are very closely related with falls in the employment over time.

Given the current (2020) health crisis many sectors and firms in the US economy stopped or reduced operations as a way to reduce the spread of the virus. As firms produce less (or nothing), they sell less (or nothing). Firms face two kinds of costs, variable and fixed. Variable costs depend on production, so if production decreases the variable costs decreases as well. The problem here is fixed costs because they never disappear, they are fixed and they have to be paid no matter what. Some firms might have the possibility to pay fixed costs with reduced or null revenues for a while (days, weeks, probably a little bit more), but definitely not for long. I believe it is clear what happen next. Some firms did not make it, they could not survive and they simply went bankrupt and definitely closed operations. These firms had employees and now they are unemployed. Even those firms who are still operating, in some cases they had to reduce the payroll, and some employees are now unemployed. Less aggregate production and more families without an income reduce the aggregate supply and demand. This is why this current-next economic crisis has no precedent.

Having easy access to financial and economic data is important to facilitate the data analysis. However, it is even more important to be able to manipulate the financial and economic data correctly to communicate facts and discover new insights to make better decisions.

## Technical analysis.

Technical analysis is the forecasting of future financial price movements based on an examination of past price movements and volume of trading. Technical analysis is applicable to stocks, indexes, commodities, futures or any tradable instrument where the price is influenced by the forces of supply and demand. This analysis is limited because it fails to incorporate other forces and factors that can influence the price of the security. Although this analysis is limited, it is still quite popular, and given that we now know how to get financial prices, it seems convenient to illustrate the basics of technical analysis.

Let's use FANG data again.

```{r}
# Get AAPL and AMZN stock prices.
AAPL <- tq_get("AAPL", get = "stock.prices", from = "2015-09-01", 
               to = "2016-12-31")
```

Let's begin with one plot.

```{r}
# Plot the data.
AAPL |>
    ggplot(aes(x = date, y = close)) + geom_line() +
    labs(title = "Apple Line Chart", 
         y = "Closing Price", x = "") +
    theme_tq()
```

The plot above is about closing prices. However, we also have open and close prices per day. We could take advantage of this by plotting vertical lines per day. The length of the daily vertical lines represents the difference between the open and close prices. To make it more informative, blue lines are those cases when the close price is greater than the open price, and red lines are those cases when the close price is lower than the open price.

```{r}
# Plot the data.
AAPL |>
    ggplot(aes(x = date, y = close)) +
    geom_candlestick(aes(open = open, high = high, low = low, 
                         close = close)) +
    labs(title = "AAPL Candlestick Chart", y = "Closing Price", 
         x = "") + theme_tq()
```

There are some blank spaces. This is simply because the close price of yesterday is not always exactly the same as the open price of today. Local stock markets close on weekends, and there are also holidays.

These kinds of charts are difficult to read when we have many observations. Let's do a zoom:

```{r}
# A candlestick plot.
AAPL |>
    ggplot(aes(x = date, y = close)) +
    geom_candlestick(aes(open = open, high = high, low = low, 
                         close = close)) +
  coord_x_date(xlim = c("2016-12-15", "2016-12-31"), 
               ylim = c(28.75, 29.5)) +
    labs(title = "AAPL Candlestick Chart (zoom)", 
         y = "Closing Price", x = "") + theme_tq()
```

A formal interpretation is difficult given the limitations of this analysis. However, the main idea is the following. Consider the stock is increasing quickly, then it is believed that before a fall in the price, the stock will increase at a lower speed. Big blue bars are eventually followed by smaller blue bars before exhibiting a price fall (a red bar).[^4] The same logic can be applied the other way around. A dramatic fall in the price eventually reach a floor. This is, big red bars are eventually followed by smaller red bars before experiencing a price increase.

[^4]: The logic behind this is not very different from what we have heard about "flatten the curve" in the context of the 2020 pandemic. As the curve increases, the high speed of increase is captured by big vertical blue bars. It is expected that the speed of increase slows down before the curve is flat, and this slowing down is captured by smaller vertical blue lines. So, before the curve is flat and starts to decrease, the blue vertical lines become smaller and smaller.

Could you guess what will happen with the price given the chart above? Seems difficult as the last four observations are consecutive blue-red-blue-red. Then, this indicator alone, without any complementary analysis, does not seem to deliver a clear signal.

Moving averages are supposed to anticipate price movements. The idea is the following. We have two line plots, one is the original evolution of the price chart in black and the second is the moving average in blue. In this case we have a 30-day moving average. The blue line is simply the average of the last 30-day stock prices. In the code below, this value is easily modified by changing the value of $n$, in this case $n=30$. The blue line (moving average) seems to anticipate what happens to the black line. The way we interpret the moving average is simple. If the black line crosses the blue from top to down in $t$, then we are expected to anticipate a drop in the stock price in $t+1$. In case the black line remains below the blue after $t+1$, then we expect the stock price to keep falling in the following periods.

If the black line crosses the blue from down to top, then we are supposed to anticipate an increase in the stock price. The sign is stronger when the black line crosses the blue line showing a steeper slope. What happens in practice is that the value of $n$ should be calibrated until we fit the moving average with the behaviour of the price stock. This indicator alone is far from being perfect as there might be a lot of contrary signals which might make it difficult to follow the interpretation as we explained above.

```{r}
# The simple moving average (SMA) plot. 
AAPL |>
    ggplot(aes(x = date, y = close)) +
    geom_line(aes(open = open, high = high, low = low, 
                         close = close))  +
    geom_ma(ma_fun = SMA, n = 30, linetype = 1, size = 1.25) +
    labs(title = "Apple Moving average chart",
         subtitle = "30-Day SMA",
         y = "Closing Price", x = "") + theme_tq()
```

There is a price fall a few weeks before January 2016 and a few weeks after January 2016. This price fall was correctly anticipated by the moving average. Then the stock price increased a bit more than 110 USD, this was also correctly anticipated by the moving average. The period around July 2016 is less clear. By the end of the time-series, the black line is above the blue, so trying to follow our previous explanation this means that we should not expect a significant drop in the stock price.

```{r}
AAPL_recent <- tq_get("AAPL", get = "stock.prices", 
                      from = "2016-12-30", to = "2017-01-12")
AAPL_recent
```

The Bollinger Bands are envelopes plotted at a standard deviation level above and below a simple moving average of the price. Because the distance of the bands is based on standard deviation, they are supposed to adjust to volatility swings in the underlying price. This indicator can help us to understand the size of the expected change in the future. If the Bollinger Bands become wider then we should expect drastic changes in the stock price.

```{r}
# Bollinger bands and simple moving average.
AAPL |>
    ggplot(aes(x = date, y = close, open = open,
               high = high, low = low, close = close)) +
    geom_line() +
    geom_bbands(ma_fun = SMA, sd = 2, n = 30,
                linetype = 2, size = 1, alpha = 0.2,
                fill        = palette_light()[[1]],
                color_bands = palette_light()[[1]],
                color_ma    = palette_light()[[2]]) +
    labs(title = "BBands with SMA", y = "Closing Price", x = "") +
    theme_tq()
```

Let's look at the very last observation. The price line is above the moving average (now in red, dotted line). This means that we should not expect a drop in the stock price in the following periods. However, the Bollinger Bands suggest that the price is currently very close to the upper bound, plus the upper bounds is also close to the historical maximum price at least in this plot. In sum, the last price is 115.82 USD and we do not expect a fall in the stock price according to the moving average and the expected price change is in the range of 107 to 119 USD approximately.

In case you may have a different view or concerns about the previous interpretation then you now realize the pitfalls and the disadvantages of this kind of analysis when it is conducted as a simple chart read. Although, the technical analysis is popular, it could lead to different interpretations easily when we interpret one or two indicators by eye. This does not mean we have to ignore this kind of analysis because we can always incorporate formal techniques to try to validate buy and sell signals to help traders and conduct short-run investment strategies. In fact, there are very serious developments like the *quantstrat* package, which provides a generic infrastructure to model and backtest signal-based quantitative strategies.

We can show the simple moving average for Facebook.

```{r}
# The simple moving average (SMA) plot. 
FANG |>
  filter(symbol == "FB") |>
  ggplot(aes(x = date, y = close)) +
  geom_line(aes(open = open, high = high, low = low, 
                close = close))  +
  geom_ma(ma_fun = SMA, n = 60, linetype = 1, size = 1.25) +
  labs(title = "Facebook Moving average chart",
       subtitle = "30-Day SMA",
       y = "Closing Price", x = "") + theme_tq()
```

This suggests that the stock price will decrease in the near future. Let's see if the moving average signal is correct.

```{r}
FANG |>
  filter(symbol == "FB") |>
  filter(date >= "2014-01-01" & date <= "2014-02-01")
```

The moving average sent the right stock price movement signal.

